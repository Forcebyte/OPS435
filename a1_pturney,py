#!/usr/bin/env python3

import os
import sys

# Defines usage function to refer to later
def usage():
	print ("Usage...")
	exit()

def validdate(argdate):
	#Test if the date entered is actually a date
	if isinstance(argdate, int):
		argdate = str(argdate)
	if len(argdate) != 8 or not argdate.isdigit():
		print("Error: Wrong date entered")
		return("False")

	#Split the entered value into YYYY/MM/DD
	argyear = argdate[0:4]
	#print ("Year = " + str(argyear))

	argmonth = argdate[4:6]
	#print ("Month = " + str(argmonth))

	argday = argdate[6:8]
	#print ("Day = " + str(argday))

	#Check to see if valid month or day is entered
	if int(argmonth) > 12:
		print("Error: Wrong month entered")
		return("False")
	elif int(argday) > 31:
		print ("Error: Wrong day entered")
		return("False")
	else:
		return("True")


def leapyear(argyear):
#Check to see if year is a leap year
	lyear = argyear % 4
	if lyear == 0:
		lyearstatus = "True" # This is a leap year
	else:
		lyearstatus = "False"
	lyear = argyear % 100
	if lyear == 0:
		lyearstatus = "False"
	lyear = argyear % 400
	if lyear == 0:
		lyearstatus = "True"
	return(lyearstatus)


def tomorrow(argdate):
		#Function returns tomorrow's date with argument argdate given
		if isinstance(argdate, int):
			argdate = str(argdate)
		if validdate(argdate) == "True":
			argyear = int(argdate[0:4])
			argmonth = int(argdate[4:6])
			argday = int(argdate[6:])
			#Check to see if leapyear exists, if exists, add days to feburary
			if leapyear(argyear) == "True":
				feb_max = 29
			else:
				feb_max = 28

			#Resultant will be what day we want to return, which is the next day
			resultday = argday + 1

			#MaxMonth is the maximum number of days per month, (#:# = Month:Day)
			MaxMonth = { 1:31, 2:feb_max, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}

			#If the day is above the maximum number of days for the month, cycle to the next month as
			#the first day,

			if resultday > MaxMonth[argmonth]:
				varday = resultday % MaxMonth[argmonth]
				resultmonth = argmonth + 1
			else:
				varday = resultday
				resultmonth = argmonth
			if resultmonth > 12:
				varmonth = 1
				varyear  = argyear + 1
			else:
				varmonth = resultmonth
				varyear = argyear
			nextdate = str(varyear)+str(varmonth).zfill(2)+str(varday).zfill(2)
			return nextdate
		else:
			exit()


def yesterday(argdate):
		#Function returns yesterday's date with argument argdate given
		if isinstance(argdate, int):
			argdate = str(argdate)
		if validdate(argdate) == "True":
			argyear = int(argdate[0:4])
			argmonth = int(argdate[4:6])
			argday = int(argdate[6:])
			#Check to see if leapyear exists, if exists, add days to feburary
			if leapyear(argyear) == "True":
				feb_max = 29
			else:
				feb_max = 28

			#Resultant will be what day we want to return, which is the next day
			resultday = argday - 1

			#MaxMonth is the maximum number of days per month, (#:# = Month:Day)
			MaxMonth = { 1:31, 2:feb_max, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}

			#If the day is above the max number of days for the month, cycle to next month but in reverse

			if resultday < 1:
			#Change the day
				resultmonth = argmonth - 1
				if resultmonth < 1:
						varday = 31
				else:
					changement = MaxMonth[resultmonth]
					varday = changement
			else:
				varday = resultday
				resultmonth = argmonth
			if resultmonth < 1:
			#Change the month
				varmonth = 12
				varyear  = argyear - 1
			else:
				varmonth = resultmonth
				varyear = argyear
			nextdate = str(varyear)+str(varmonth).zfill(2)+str(varday).zfill(2)
			return nextdate
		else:
			exit()


def dbda(argdate,days):
		#Round Days such that it always returns a whole number
		if __name__ != "__main__":
				argstep = "False"
		days = round(int(days))
	#If the days are positive, run the tomorrow function
		if days > 0:
			if argstep == "True":
				print(tomorrow(argdate))
			tomorrowdate = tomorrow(argdate)
			while days != 1:
				tomorrowdate = tomorrow(tomorrowdate)
				if argstep == "True":
					print(str(tomorrowdate))
				days = days - 1
			if argstep == "False":
				print(str(tomorrowdate))

	#If the days are negative, run the yesterday function
		elif days < 0:
			if argstep == "True":
				print (yesterday(argdate))
			yesterdaydate = yesterday(argdate)
			while days != -1:
				yesterdaydate = yesterday(yesterdaydate)
				if argstep == "True":
					print(str(yesterdaydate))
				days = days + 1
			if argstep == "False":
				print(str(yesterdaydate))
		else:
				days = 0
				return argdate

if __name__ == "__main__":
	if ((len(sys.argv) >= 5 or len(sys.argv) <= 2)):
		usage()
	if sys.argv[1] == "--step":
		argstep = "True"
		argdate = sys.argv[2]
		argoption = sys.argv[3]
		dbda(argdate,argoption)
	else:
		argstep = "False"
		argdate = sys.argv[1]
		argoption = sys.argv[2]
		dbda(argdate,argoption)
